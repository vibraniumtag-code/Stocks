      - name: Apply move to positions.csv
        env:
          MOVE_ID: ${{ inputs.move_id }}
          MOVE_TYPE: ${{ inputs.move_type }}
          TICKER: ${{ inputs.ticker }}
          OPTION_NAME: ${{ inputs.option_name }}
          SELL_CONTRACTS: ${{ inputs.sell_contracts }}
          ADD_CONTRACTS: ${{ inputs.add_contracts }}
          BUY_CONTRACTS: ${{ inputs.buy_contracts }}
          STRATEGY: ${{ inputs.strategy }}
          EXPIRY: ${{ inputs.expiry }}
          OPTION_SYMBOL: ${{ inputs.option_symbol }}
          OPTION_ENTRY_PRICE: ${{ inputs.option_entry_price }}
          UNDERLYING_ENTRY_PRICE: ${{ inputs.underlying_entry_price }}
          CSV_BLOB: ${{ inputs.csv_blob }}
        run: |
          python - <<'PY'
          import csv, os, re
          from datetime import datetime

          POS_FILE = "positions.csv"
          DOCS_POS_FILE = os.path.join("docs", "positions.csv")
          LEDGER = "executions_ledger.csv"

          def today():
              return datetime.utcnow().strftime("%Y-%m-%d")

          def norm(s): 
              return (s or "").strip()

          def ffloat(s):
              s = (s or "").strip()
              if not s: return None
              try:
                  v = float(s)
                  return v if v > 0 else None
              except:
                  return None

          def fint(s):
              s = (s or "").strip()
              if not s: return 0
              try:
                  v = int(float(s))
                  return max(v, 0)
              except:
                  return 0

          def ensure_docs_dir():
              os.makedirs("docs", exist_ok=True)

          def write_text(path, content):
              tmp = path + ".tmp"
              with open(tmp, "w", encoding="utf-8", newline="") as f:
                  f.write(content)
              os.replace(tmp, path)

          def load_positions():
              if not os.path.exists(POS_FILE):
                  raise SystemExit(f"{POS_FILE} not found")
              with open(POS_FILE, "r", newline="", encoding="utf-8") as f:
                  r = csv.DictReader(f)
                  fieldnames = r.fieldnames or []
                  rows = list(r)
              return fieldnames, rows

          def normalize_schema(fieldnames, rows):
              desired = ["ticker","option_name","option_entry_price","entry_date","underlying_entry_price","contracts"]
              if [c.strip() for c in fieldnames] != desired:
                  fieldnames = desired
                  rows = [{
                      "ticker": row.get("ticker",""),
                      "option_name": row.get("option_name",""),
                      "option_entry_price": row.get("option_entry_price",""),
                      "entry_date": row.get("entry_date",""),
                      "underlying_entry_price": row.get("underlying_entry_price",""),
                      "contracts": row.get("contracts","0"),
                  } for row in rows]
              return fieldnames, rows

          def row_contracts(row):
              try:
                  return max(int(float(row.get("contracts","0") or 0)), 0)
              except:
                  return 0

          def decode_occ(occ: str):
              occ = (occ or "").strip().upper()
              if not re.match(r"^[A-Z]{1,6}\d{6}[CP]\d{8}$", occ):
                  return None
              # underlying is leading letters
              first_digit = re.search(r"\d", occ).start()
              und = occ[:first_digit]
              rest = occ[first_digit:]
              yy = int(rest[0:2]); mm = int(rest[2:4]); dd = int(rest[4:6])
              cp = rest[6]
              strike_raw = int(rest[7:15])
              strike = strike_raw / 1000.0
              yyyy = 2000 + yy
              expiry = f"{yyyy:04d}-{mm:02d}-{dd:02d}"
              side = "C" if cp == "C" else "P"
              if abs(strike - round(strike)) < 1e-9:
                  strike_s = str(int(round(strike)))
              else:
                  strike_s = f"{strike:.3f}".rstrip("0").rstrip(".")
              return und, expiry, side, strike_s

          move_id   = norm(os.getenv("MOVE_ID"))
          move_type = norm(os.getenv("MOVE_TYPE")).upper()
          ticker    = norm(os.getenv("TICKER")).upper()
          option_name = norm(os.getenv("OPTION_NAME"))

          sell_n = fint(os.getenv("SELL_CONTRACTS"))
          add_n  = fint(os.getenv("ADD_CONTRACTS"))
          buy_n  = fint(os.getenv("BUY_CONTRACTS"))

          option_symbol = norm(os.getenv("OPTION_SYMBOL")).upper()
          opt_entry_v = ffloat(os.getenv("OPTION_ENTRY_PRICE"))
          und_entry_v = ffloat(os.getenv("UNDERLYING_ENTRY_PRICE"))

          csv_blob = os.getenv("CSV_BLOB") or ""

          # -------------------------------
          # NEW: UPSERT_BULK (editor save)
          # -------------------------------
          if move_type == "UPSERT_BULK":
              if not csv_blob.strip():
                  raise SystemExit("UPSERT_BULK requires csv_blob")
              ensure_docs_dir()
              # write to repo root + docs/
              write_text(POS_FILE, csv_blob if csv_blob.endswith("\n") else csv_blob + "\n")
              write_text(DOCS_POS_FILE, csv_blob if csv_blob.endswith("\n") else csv_blob + "\n")

              # ledger
              led_exists = os.path.exists(LEDGER)
              with open(LEDGER, "a", newline="", encoding="utf-8") as f:
                  w = csv.writer(f)
                  if not led_exists:
                      w.writerow(["ts_utc","move_id","move_type","notes"])
                  w.writerow([datetime.utcnow().isoformat()+"Z", move_id, move_type, "bulk overwrite positions.csv + docs/positions.csv"])
              print("✅ UPSERT_BULK applied to positions.csv and docs/positions.csv")
              raise SystemExit(0)

          # -------------------------------
          # Existing logic: SELL / ADD / BUY
          # -------------------------------
          fieldnames, rows = load_positions()
          fieldnames, rows = normalize_schema(fieldnames, rows)

          def find_row():
              for row in rows:
                  if (row.get("ticker","").strip().upper() == ticker and
                      row.get("option_name","").strip() == option_name):
                      return row
              return None

          changed = False

          if move_type in ("SELL","ADD"):
              if not option_name:
                  raise SystemExit(f"{move_type} requires option_name")
              if move_type == "SELL" and sell_n <= 0:
                  raise SystemExit("SELL requires sell_contracts > 0")
              if move_type == "ADD" and add_n <= 0:
                  raise SystemExit("ADD requires add_contracts > 0")

              row = find_row()
              if row is None:
                  raise SystemExit(f"Could not find position to {move_type}: {ticker} | {option_name}")

              cur = row_contracts(row)
              newc = max(cur - sell_n, 0) if move_type == "SELL" else (cur + add_n)
              if newc != cur:
                  row["contracts"] = str(newc)
                  changed = True

          elif move_type == "BUY":
              if buy_n <= 0:
                  raise SystemExit("BUY requires buy_contracts > 0")

              if not option_name:
                  decoded = decode_occ(option_symbol)
                  if not decoded:
                      raise SystemExit("BUY requires option_name OR a valid option_symbol to build it")
                  und, exp, side, strike_s = decoded
                  if not ticker:
                      ticker = und
                  option_name = f"{ticker} {exp} {side} {strike_s}"

              if opt_entry_v is None or und_entry_v is None:
                  raise SystemExit("BUY requires option_entry_price and underlying_entry_price (both > 0)")

              row = find_row()
              if row is not None:
                  cur = row_contracts(row)
                  row["contracts"] = str(cur + buy_n)
                  changed = True
              else:
                  rows.append({
                      "ticker": ticker,
                      "option_name": option_name,
                      "option_entry_price": f"{opt_entry_v:.4f}",
                      "entry_date": today(),
                      "underlying_entry_price": f"{und_entry_v:.2f}",
                      "contracts": str(buy_n),
                  })
                  changed = True
          else:
              raise SystemExit(f"Unknown move_type={move_type}")

          if changed:
              tmp = POS_FILE + ".tmp"
              with open(tmp, "w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fieldnames)
                  w.writeheader()
                  w.writerows(rows)
              os.replace(tmp, POS_FILE)

              # also copy to docs
              ensure_docs_dir()
              tmp2 = DOCS_POS_FILE + ".tmp"
              with open(tmp2, "w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fieldnames)
                  w.writeheader()
                  w.writerows(rows)
              os.replace(tmp2, DOCS_POS_FILE)

              print("✅ positions.csv updated and copied to docs/positions.csv")
          else:
              print("No changes needed")

          led_exists = os.path.exists(LEDGER)
          with open(LEDGER, "a", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              if not led_exists:
                  w.writerow(["ts_utc","move_id","move_type","ticker","option_name","sell_contracts","add_contracts","buy_contracts","option_entry_price","underlying_entry_price"])
              w.writerow([
                  datetime.utcnow().isoformat()+"Z",
                  move_id, move_type, ticker, option_name,
                  sell_n, add_n, buy_n,
                  f"{opt_entry_v:.4f}" if opt_entry_v else "",
                  f"{und_entry_v:.2f}" if und_entry_v else "",
              ])
          PY