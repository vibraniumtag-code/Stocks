<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Positions</title>
<style>
:root{
  --bg:#0b1020; --panel:#0f172a; --border:rgba(255,255,255,.08);
  --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.62);
  --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
  --chip:rgba(255,255,255,.07); --shadow:0 14px 50px rgba(0,0,0,.45);
  --radius:14px; --font:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  --focus:rgba(124,58,237,.35);
}
*{box-sizing:border-box}
body{
  margin:0;padding:22px;
  background:
    radial-gradient(1200px 700px at 20% 0%, rgba(124,58,237,.25), transparent 55%),
    radial-gradient(900px 600px at 95% 12%, rgba(34,197,94,.18), transparent 50%),
    var(--bg);
  color:var(--text); font-family:var(--font);
}
.container{max-width:1200px;margin:auto}
h1{margin:0;font-size:24px}
.sub{margin-top:6px;color:var(--muted);font-size:13px}
.version{
  display:inline-block;margin-top:10px;
  padding:8px 12px;border-radius:999px;
  background:rgba(124,58,237,.18);
  border:1px solid rgba(124,58,237,.35);
  font-weight:800;font-size:13px;
}
.panel{
  margin-top:14px;background:rgba(255,255,255,.04);
  border:1px solid var(--border);border-radius:var(--radius);
  box-shadow:var(--shadow);overflow:hidden;
}
.toolbar{
  padding:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;
}
.chip{
  padding:7px 10px;border-radius:999px;
  background:var(--chip);border:1px solid var(--border);
  font-size:13px;color:var(--muted);display:flex;gap:8px;align-items:center;
}
.dot{width:8px;height:8px;border-radius:50%;background:var(--warn)}
.dot.ok{background:var(--ok)}
.dot.bad{background:var(--bad)}
.spacer{flex:1}
.input{
  display:flex;gap:8px;align-items:center;
  padding:8px 10px;border-radius:12px;
  border:1px solid var(--border);background:rgba(0,0,0,.2);
  min-width:240px;
}
.input input{border:0;outline:none;background:transparent;color:var(--text);width:100%}
.btn{
  padding:9px 12px;border-radius:12px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.06);
  color:var(--text);font-weight:700;cursor:pointer;
  display:inline-flex;gap:8px;align-items:center;
}
.btn.primary{background:rgba(124,58,237,.25);border-color:rgba(124,58,237,.4)}
.btn.success{background:rgba(34,197,94,.22);border-color:rgba(34,197,94,.4)}
.btn.danger{background:rgba(239,68,68,.2);border-color:rgba(239,68,68,.4)}
.btn:disabled{opacity:.45;cursor:not-allowed}
.tableWrap{overflow:auto;border-top:1px solid var(--border)}
table{width:100%;border-collapse:collapse;min-width:900px}
thead th{
  position:sticky;top:0;
  background:rgba(10,14,28,.95);
  padding:10px;font-size:12px;color:var(--muted);
  border-bottom:1px solid var(--border);
  text-align:left;
  user-select:none;
}
tbody td{
  padding:9px 10px;font-size:13px;
  border-bottom:1px solid rgba(255,255,255,.06);
  white-space:nowrap;
}
tbody tr:hover td{background:rgba(255,255,255,.03)}
td[contenteditable]{outline:none;border-radius:8px}
td[contenteditable]:focus{box-shadow:0 0 0 3px var(--focus);background:rgba(124,58,237,.08)}
.log{
  margin-top:12px;padding:10px;border-radius:12px;
  background:rgba(0,0,0,.25);border:1px solid var(--border);
  font-size:12px;white-space:pre-wrap;display:none;max-height:320px;overflow:auto;
}
pre.err{
  margin-top:12px;padding:10px;border-radius:12px;
  background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.3);
  font-size:12px;white-space:pre-wrap;overflow:auto;
}
.overlay{
  position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:none;align-items:center;justify-content:center;
  padding:18px;
}
.modal{
  width:820px;max-width:95%;
  background:rgba(15,23,42,.95);
  border:1px solid var(--border);
  border-radius:16px;box-shadow:var(--shadow);
  overflow:hidden;
}
.mh{padding:14px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;gap:10px}
.mb{padding:14px;display:grid;gap:12px}
.mf{padding:14px;border-top:1px solid var(--border);display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap}
.field{display:grid;gap:6px}
.field input{
  padding:10px;border-radius:12px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.25);color:var(--text)
}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
a{color:#c4b5fd}
.small{color:var(--muted);font-size:12px}
</style>
</head>

<body>
<div class="container">
  <h1>Positions</h1>
  <div class="sub">Edit ‚Ä¢ Download ‚Ä¢ Commit to GitHub (root CSV) + commit cash to docs/cash.txt</div>
  <div class="version">POSITION GUI v2026-01-26-CASH-TXT</div>

  <!-- CASH PANEL -->
  <div class="panel">
    <div class="toolbar">
      <span class="chip"><span id="cashDot" class="dot"></span><span id="cashStatus">Cash: loading‚Ä¶</span></span>
      <span class="chip">File: <b>docs/cash.txt</b></span>
      <div class="spacer"></div>
      <div class="input" style="min-width:320px;">üíµ
        <input id="cashInput" inputmode="decimal" placeholder="Enter free cash (e.g., 12345.67)">
      </div>
      <button class="btn success" id="commitCash" disabled>‚úÖ Commit Cash</button>
    </div>
  </div>

  <!-- POSITIONS PANEL -->
  <div class="panel">
    <div class="toolbar">
      <span class="chip"><span id="dot" class="dot"></span><span id="status">Loading‚Ä¶</span></span>
      <span class="chip">Load: <b>positions.csv</b></span>
      <div class="spacer"></div>
      <div class="input">üîé <input id="filter" placeholder="Filter rows‚Ä¶"></div>
      <button class="btn" id="addRow">‚ûï Add</button>
      <button class="btn" id="download">‚¨áÔ∏è Download</button>
      <button class="btn primary" id="commit" disabled>‚úÖ Commit</button>
      <button class="btn" id="reset" disabled>‚Ü©Ô∏è Reset</button>
    </div>
    <div class="tableWrap"><table id="tbl"></table></div>
  </div>

  <div id="log" class="log"></div>
  <div id="fatal"></div>
</div>

<!-- Commit Modal -->
<div class="overlay" id="overlay">
  <div class="modal">
    <div class="mh">
      <div>
        <b>Commit to GitHub</b>
        <div class="small">Writes <b>positions.csv</b> at repo root. Token is stored only in this browser.</div>
      </div>
      <button class="btn" id="close">‚úñ</button>
    </div>

    <div class="mb">
      <div class="grid2">
        <div class="field"><label class="small">Owner</label><input id="owner" value="vibraniumtag-code"></div>
        <div class="field"><label class="small">Repo</label><input id="repo" value="Stocks"></div>
      </div>
      <div class="grid2">
        <div class="field"><label class="small">Branch</label><input id="branch" value="main"></div>
        <div class="field"><label class="small">Path</label><input id="path" value="positions.csv"></div>
      </div>

      <div class="field">
        <label class="small">Commit message</label>
        <input id="message" value="Update positions.csv (web)">
      </div>

      <div class="field">
        <label class="small">Token (fine-grained PAT, Contents: Read & Write)</label>
        <input id="token" type="password" placeholder="github_pat_..." autocomplete="current-password">
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="btn" id="test">üîç Test access</button>
          <button class="btn danger" id="clearToken">üßπ Clear saved token</button>
        </div>
      </div>

      <div id="result"></div>
    </div>

    <div class="mf">
      <button class="btn success" id="commitNow">‚úÖ Commit now</button>
    </div>
  </div>
</div>

<script>
(() => {
  const csvUrl = 'positions.csv?ts=' + Date.now();
  const TOKEN_KEY = 'stocks_pat_token_v2';

  // NEW: cash file path
  const CASH_PATH = 'docs/cash.txt';

  const tbl = document.getElementById('tbl');
  const filter = document.getElementById('filter');
  const addRow = document.getElementById('addRow');
  const download = document.getElementById('download');
  const commitBtn = document.getElementById('commit');
  const resetBtn = document.getElementById('reset');

  // cash UI
  const cashInput = document.getElementById('cashInput');
  const commitCashBtn = document.getElementById('commitCash');
  const cashStatusEl = document.getElementById('cashStatus');
  const cashDotEl = document.getElementById('cashDot');

  const overlay = document.getElementById('overlay');
  const closeBtn = document.getElementById('close');
  const commitNow = document.getElementById('commitNow');
  const testBtn = document.getElementById('test');

  const ownerEl = document.getElementById('owner');
  const repoEl = document.getElementById('repo');
  const branchEl = document.getElementById('branch');
  const pathEl = document.getElementById('path');
  const msgEl = document.getElementById('message');
  const tokenEl = document.getElementById('token');
  const clearTokenBtn = document.getElementById('clearToken');

  const logEl = document.getElementById('log');
  const fatalEl = document.getElementById('fatal');
  const statusEl = document.getElementById('status');
  const dotEl = document.getElementById('dot');
  const resultEl = document.getElementById('result');

  let headers = [];
  let data = [];
  let originalData = [];
  let dirty = false;
  let sortState = { col: -1, dir: 1 };

  // cash state
  let cashOriginal = '';
  let cashDirty = false;

  // ---------- helpers ----------
  function showLog(text){
    logEl.style.display = 'block';
    logEl.textContent += (logEl.textContent ? "\n" : "") + text;
  }
  function clearLog(){
    logEl.textContent = '';
    logEl.style.display = 'none';
  }
  function fatal(msg){
    const m = (msg && msg.stack) ? msg.stack : String(msg);
    fatalEl.innerHTML = `<pre class="err">${m}</pre>`;
  }
  function setStatus(kind, text){
    statusEl.textContent = text;
    dotEl.className = 'dot ' + (kind === 'ok' ? 'ok' : kind === 'bad' ? 'bad' : '');
  }
  function setCashStatus(kind, text){
    cashStatusEl.textContent = text;
    cashDotEl.className = 'dot ' + (kind === 'ok' ? 'ok' : kind === 'bad' ? 'bad' : '');
  }
  function setResult(html){ resultEl.innerHTML = html; }
  function esc(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
  function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }

  window.addEventListener('error', (e) => fatal(e.error || e.message));
  window.addEventListener('unhandledrejection', (e) => { fatal(e.reason); try{e.preventDefault()}catch{} });

  // ---------- token persistence ----------
  try {
    const saved = localStorage.getItem(TOKEN_KEY);
    if (saved) tokenEl.value = saved;
  } catch {}
  tokenEl.addEventListener('input', () => {
    try {
      const v = tokenEl.value.trim();
      if (v) localStorage.setItem(TOKEN_KEY, v);
      else localStorage.removeItem(TOKEN_KEY);
    } catch {}
  });
  clearTokenBtn.onclick = () => {
    try{ localStorage.removeItem(TOKEN_KEY); }catch{}
    tokenEl.value = '';
    alert('Token cleared from this browser.');
  };

  // ---------- CSV ----------
  function parseCSV(text){
    const rows = [];
    let row = [], cur = '', inQuotes = false;
    for (let i=0; i<text.length; i++){
      const c = text[i], n = text[i+1];
      if (c === '"' && inQuotes && n === '"'){ cur += '"'; i++; continue; }
      if (c === '"'){ inQuotes = !inQuotes; continue; }
      if (!inQuotes && (c === ',' || c === '\n' || c === '\r')){
        row.push(cur); cur = '';
        if (c === '\n'){
          if (row.some(v => v.trim() !== '')) rows.push(row);
          row = [];
        }
        continue;
      }
      cur += c;
    }
    if (cur.length || row.length){ row.push(cur); rows.push(row); }
    return rows;
  }
  function csvEscape(s){
    s = (s ?? '').toString();
    if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }
  function toCSV(headers, rows){
    const lines = [];
    lines.push(headers.map(csvEscape).join(','));
    for (const r of rows){
      lines.push(headers.map((_, i) => csvEscape(r[i] ?? '')).join(','));
    }
    return lines.join('\n') + '\n';
  }

  // Safari-safe base64
  function b64encodeUTF8(str){
    const bytes = new TextEncoder().encode(str);
    let binary = '';
    for (let i=0; i<bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }
  // Decode base64 (utf-8) from GitHub API content
  function b64decodeUTF8(b64){
    const binary = atob(b64.replace(/\s/g,''));
    const bytes = new Uint8Array(binary.length);
    for (let i=0; i<binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }

  // ---------- table ----------
  function markDirty(){
    dirty = true;
    commitBtn.disabled = false;
    resetBtn.disabled = false;
  }

  function sortBy(colIdx, dir){
    data.sort((a,b) => {
      const av = (a[colIdx] ?? '').toString();
      const bv = (b[colIdx] ?? '').toString();
      return av.localeCompare(bv, undefined, { numeric:true, sensitivity:'base' }) * dir;
    });
  }

  function render(){
    const q = filter.value.toLowerCase().trim();
    const visible = [];
    data.forEach((r, idx) => {
      const txt = r.join(' ').toLowerCase();
      if (!q || txt.includes(q)) visible.push(idx);
    });

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');

    headers.forEach((h, colIdx) => {
      const th = document.createElement('th');
      const arrow = (sortState.col === colIdx) ? (sortState.dir === 1 ? ' ‚ñ≤' : ' ‚ñº') : '';
      th.textContent = h + arrow;
      th.addEventListener('click', () => {
        if (sortState.col === colIdx) sortState.dir *= -1;
        else { sortState.col = colIdx; sortState.dir = 1; }
        sortBy(colIdx, sortState.dir);
        render();
      });
      trh.appendChild(th);
    });
    thead.appendChild(trh);

    const tbody = document.createElement('tbody');
    visible.forEach((rowIdx) => {
      const tr = document.createElement('tr');
      headers.forEach((_, colIdx) => {
        const td = document.createElement('td');
        td.contentEditable = "true";
        td.spellcheck = false;
        td.textContent = (data[rowIdx][colIdx] ?? '').toString();
        td.addEventListener('input', () => {
          data[rowIdx][colIdx] = td.textContent;
          markDirty();
        });
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });

    tbl.innerHTML = '';
    tbl.appendChild(thead);
    tbl.appendChild(tbody);
  }

  // ---------- GitHub API ----------
  function apiHeaders(token){
    return {
      'Accept': 'application/vnd.github+json',
      'Authorization': `Bearer ${token}`,
      'X-GitHub-Api-Version': '2022-11-28'
    };
  }
  const ghPath = (p) => encodeURIComponent(p).replace(/%2F/g,'/');

  async function ghGetFile({owner, repo, path, branch, token}){
    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${ghPath(path)}?ref=${encodeURIComponent(branch)}`;
    const res = await fetch(url, { headers: apiHeaders(token) });
    const raw = await res.text();
    let json = {};
    try { json = JSON.parse(raw); } catch {}
    return { url, res, raw, json };
  }

  async function ghPutFile({owner, repo, path, branch, token, message, contentBase64, sha}){
    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${ghPath(path)}`;
    const body = { message, content: contentBase64, branch };
    if (sha) body.sha = sha;

    const res = await fetch(url, {
      method: 'PUT',
      headers: { ...apiHeaders(token), 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });

    const raw = await res.text();
    let json = {};
    try { json = JSON.parse(raw); } catch {}

    if (!res.ok){
      throw new Error(`PUT failed (${res.status}): ${json.message || raw}`);
    }
    return json;
  }

  // ---------- CASH logic ----------
  function normalizeCashInput(v){
    // allow commas/spaces, keep digits, dot, minus
    const s = String(v ?? '').trim().replace(/,/g,'');
    if (!s) return '';
    if (!/^-?\d+(\.\d+)?$/.test(s)) return null; // invalid
    // keep as-is but trim extra zeros? not necessary; just return parsed -> string
    const n = Number(s);
    if (!Number.isFinite(n)) return null;
    return String(n);
  }

  function markCashDirty(){
    cashDirty = true;
    commitCashBtn.disabled = false;
    setCashStatus('warn', 'Cash: modified (not committed)');
  }

  cashInput.addEventListener('input', () => {
    // live validate
    const n = normalizeCashInput(cashInput.value);
    if (n === null){
      commitCashBtn.disabled = true;
      setCashStatus('bad', 'Cash: invalid number');
      cashDirty = true; // still dirty, but can't commit
      return;
    }
    if (n === cashOriginal){
      cashDirty = false;
      commitCashBtn.disabled = true;
      setCashStatus('ok', 'Cash: up to date');
      return;
    }
    if (n === '') {
      // allow empty but treat as dirty (will write empty file)
      markCashDirty();
      return;
    }
    markCashDirty();
  });

  commitCashBtn.addEventListener('click', async () => {
    try{
      clearLog(); setResult('');
      const owner = ownerEl.value.trim();
      const repo = repoEl.value.trim();
      const branch = branchEl.value.trim() || 'main';
      const token = tokenEl.value.trim();
      if (!owner || !repo || !token) throw new Error('Owner, repo, and token are required.');

      const normalized = normalizeCashInput(cashInput.value);
      if (normalized === null) throw new Error('Cash value is not a valid number.');
      const contentText = (normalized === '' ? '' : normalized) + '\n';

      setCashStatus('warn', 'Cash: committing‚Ä¶');
      showLog(`CASH COMMIT ‚Üí ${owner}/${repo} branch=${branch} path=${CASH_PATH}`);

      // read SHA (file may not exist)
      const info = await ghGetFile({owner, repo, path: CASH_PATH, branch, token});
      showLog(`CASH GET ‚Üê HTTP ${info.res.status}`);
      if (!info.res.ok && info.res.status !== 404){
        throw new Error(`Cannot read cash file (${info.res.status}): ${info.json.message || info.raw}`);
      }
      const sha = (info.res.status === 404) ? null : (info.json.sha || null);

      const contentBase64 = b64encodeUTF8(contentText);
      const out = await ghPutFile({
        owner, repo, path: CASH_PATH, branch, token,
        message: `Update cash.txt (web): ${normalized === '' ? 'empty' : normalized}`,
        contentBase64, sha
      });

      const commitUrl = out?.commit?.html_url || '';
      const fileUrl = out?.content?.html_url || '';

      cashOriginal = normalized;
      cashDirty = false;
      commitCashBtn.disabled = true;
      setCashStatus('ok', 'Cash: committed ‚úÖ');

      showLog('CASH PUT ‚Üê OK');
      setResult(`
        <div class="chip"><span class="dot ok"></span> Cash committed</div>
        <div class="small" style="margin-top:8px;">
          ${commitUrl ? `Commit: <a href="${commitUrl}" target="_blank" rel="noreferrer">open</a><br>` : ''}
          ${fileUrl ? `File: <a href="${fileUrl}" target="_blank" rel="noreferrer">open</a>` : ''}
        </div>
      `);
      alert('Cash committed ‚úÖ');
    }catch(e){
      setCashStatus('bad','Cash: commit failed');
      fatal(e);
      showLog(`ERROR: ${e.message || String(e)}`);
    }
  });

  async function loadCash(){
    try{
      setCashStatus('warn','Cash: loading‚Ä¶');
      const owner = ownerEl.value.trim();
      const repo = repoEl.value.trim();
      const branch = branchEl.value.trim() || 'main';
      const token = tokenEl.value.trim();

      // If no token yet, we can still show "ready" and let user load later by clicking commit/test.
      if (!owner || !repo){
        setCashStatus('warn','Cash: set repo settings');
        return;
      }
      if (!token){
        setCashStatus('warn','Cash: token needed to load');
        return;
      }

      const info = await ghGetFile({owner, repo, path: CASH_PATH, branch, token});
      if (info.res.status === 404){
        cashOriginal = '';
        cashInput.value = '';
        cashDirty = false;
        commitCashBtn.disabled = true;
        setCashStatus('ok','Cash: file not found (will create on commit)');
        return;
      }
      if (!info.res.ok){
        throw new Error(`Cash load failed (${info.res.status}): ${info.json.message || info.raw}`);
      }
      const decoded = b64decodeUTF8(info.json.content || '').trim();
      const normalized = normalizeCashInput(decoded);
      // If the file has weird content, keep it but show warning
      if (normalized === null && decoded !== ''){
        cashOriginal = decoded;
        cashInput.value = decoded;
        setCashStatus('warn','Cash: loaded (non-numeric content)');
        commitCashBtn.disabled = true;
        return;
      }
      cashOriginal = (normalized === null ? '' : normalized);
      cashInput.value = cashOriginal;
      cashDirty = false;
      commitCashBtn.disabled = true;
      setCashStatus('ok','Cash: loaded');
    }catch(e){
      setCashStatus('bad','Cash: load failed');
      // don‚Äôt fatal the whole page for cash load
      showLog(`CASH LOAD ERROR: ${e.message || String(e)}`);
    }
  }

  // ---------- UI events ----------
  filter.addEventListener('input', render);

  addRow.addEventListener('click', () => {
    data.unshift(headers.map(() => ''));
    markDirty();
    render();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });

  download.addEventListener('click', () => {
    const csv = toCSV(headers, data);
    const blob = new Blob([csv], { type:'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'positions.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  resetBtn.addEventListener('click', () => {
    data = deepCopy(originalData);
    dirty = false;
    commitBtn.disabled = true;
    resetBtn.disabled = true;
    sortState = { col:-1, dir:1 };
    render();
  });

  commitBtn.addEventListener('click', () => {
    clearLog();
    setResult('');
    overlay.style.display = 'flex';
  });

  closeBtn.addEventListener('click', () => overlay.style.display = 'none');
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display = 'none'; });

  testBtn.addEventListener('click', async () => {
    try{
      clearLog(); setResult('');
      const owner = ownerEl.value.trim();
      const repo = repoEl.value.trim();
      const branch = branchEl.value.trim() || 'main';
      const path = pathEl.value.trim() || 'positions.csv';
      const token = tokenEl.value.trim();
      if (!owner || !repo || !token) throw new Error('Owner, repo, and token are required.');

      showLog(`TEST ‚Üí ${owner}/${repo} ref=${branch} path=${path}`);
      const info = await ghGetFile({owner, repo, path, branch, token});
      showLog(`GET URL: ${info.url}`);
      showLog(`GET ‚Üê HTTP ${info.res.status}`);

      if (!info.res.ok && info.res.status !== 404){
        throw new Error(`Test failed (${info.res.status}): ${info.json.message || info.raw}`);
      }

      const sha = (info.res.status === 404) ? '(new file)' : (info.json.sha ? info.json.sha.slice(0,7) : '(no sha)');
      setResult(`<div class="chip"><span class="dot ok"></span> Access OK ‚Ä¢ SHA: <b>${esc(sha)}</b></div>`);

      // NEW: try load cash once token is confirmed
      await loadCash();
    }catch(e){
      fatal(e);
      showLog(`ERROR: ${e.message || String(e)}`);
    }
  });

  commitNow.addEventListener('click', async () => {
    try{
      clearLog(); setResult('');
      const owner = ownerEl.value.trim();
      const repo = repoEl.value.trim();
      const branch = branchEl.value.trim() || 'main';
      const path = pathEl.value.trim() || 'positions.csv';
      const message = msgEl.value.trim() || 'Update positions.csv (web)';
      const token = tokenEl.value.trim();
      if (!owner || !repo || !token) throw new Error('Owner, repo, and token are required.');

      showLog(`COMMIT ‚Üí ${owner}/${repo} branch=${branch} path=${path}`);

      // 1) Read current SHA
      const info = await ghGetFile({owner, repo, path, branch, token});
      showLog(`GET ‚Üê HTTP ${info.res.status}`);
      if (!info.res.ok && info.res.status !== 404){
        throw new Error(`Cannot read file (${info.res.status}): ${info.json.message || info.raw}`);
      }
      const sha = (info.res.status === 404) ? null : (info.json.sha || null);

      // 2) Build CSV and put
      const csv = toCSV(headers, data);
      const contentBase64 = b64encodeUTF8(csv);

      const out = await ghPutFile({owner, repo, path, branch, token, message, contentBase64, sha});
      const commitUrl = out?.commit?.html_url || '';
      const fileUrl = out?.content?.html_url || '';

      // mark clean
      originalData = deepCopy(data);
      dirty = false;
      commitBtn.disabled = true;
      resetBtn.disabled = true;

      showLog('PUT ‚Üê OK');
      setResult(`
        <div class="chip"><span class="dot ok"></span> Committed</div>
        <div class="small" style="margin-top:8px;">
          ${commitUrl ? `Commit: <a href="${commitUrl}" target="_blank" rel="noreferrer">open</a><br>` : ''}
          ${fileUrl ? `File: <a href="${fileUrl}" target="_blank" rel="noreferrer">open</a>` : ''}
        </div>
      `);
      overlay.style.display = 'none';
      alert('Committed ‚úÖ (open the commit link in the log/result to verify)');
    }catch(e){
      fatal(e);
      showLog(`ERROR: ${e.message || String(e)}`);
    }
  });

  // ---------- load CSV ----------
  (async () => {
    try{
      setStatus('warn','Loading‚Ä¶');
      const res = await fetch(csvUrl, { cache:'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} while fetching positions.csv`);
      const text = await res.text();

      const rows = parseCSV(text);
      if (!rows.length) throw new Error('CSV is empty.');

      headers = rows[0].map(x => x.trim());
      data = rows.slice(1).map(r => {
        const rr = r.slice(0, headers.length);
        while (rr.length < headers.length) rr.push('');
        return rr;
      });
      originalData = deepCopy(data);

      setStatus('ok','Loaded');
      render();

      // try load cash if token already saved
      await loadCash();
    }catch(e){
      setStatus('bad','Load failed');
      fatal(e);
    }
  })();
})();
</script>
</body>
</html>